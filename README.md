## 登录验证
### 短信验证码登录
```
	- 验证码设置有效期存入redis,key为用户手机号
	- 登录成功将用户保存至redis,key为uuid标识唯一用户,有效期30min,存储结构为hash,并将uuid返回至前端做为token
	- 通过RefreshInterceptor刷新登录有效期,根据token查询用户,存入threadlocal
	- 通过LoginInterceptor二重检查对登录用户进行权限校验
```
## 缓存一致性
```
	两种思路:删除缓存或者更新缓存
	- 更新缓存,如果数据库更新而没有查询,那么对redis的更新存在无效操作
	- 删除缓存
		- 先删除缓存在更新数据库
			因为缓存重建需要时间大于删除操作,因此其他线程并入概率高
		- 先更新数据库在删除缓存
```

## 缓存穿透
```
	防止非法id,由于数据库没数据,缓存也没,大量请求数据库	
	# 缓存null
	- 在对数据库查询后,如果没有数据,仍然写入redis(无效数据),注意设置有效期
	- 在缓存中取出数据后先判断是否为无效数据
	# 布隆过滤
```
## 缓存击穿
```
	大量key同时过期,导致高并发访问数据库,针对热点key
	- 互斥锁
		通过setnx指令互斥性,只有一个线程能成功(互斥).拿到锁然后进行缓存重建,防止多个线程访问数据库.防止死锁问题,锁需要设置合理的有效期.
	- 逻辑过期
		对于热点数据,提前进行缓存,并设置逻辑过期时间.不论是否过期都返回缓存中的数据,如果过期启用新线程实行缓存重建.
		实际业务代码对原数据类不加修改,新建RedisData类,包含Data及LocalTimeDate.
		
```
## 优惠券超卖
```
	- 通过乐观锁对优惠券的购买保证线程安全问题
	# 乐观锁实现: 
	- 1️⃣版本号法,每次修改数据增加版本号.实际操作版本号前,先取出版本号,进行修改数据时判断版本号是否一致,只有一致才修改
			set stock = stock -1 where version = ${version}
	- 2️⃣优化版本: 由于stock自身只会减少,不存在ABA问题,因此可以将stock作为特殊的版本.
	- set stock = stock -1 where stock > 0(优化)
```
## 一人一单
```
	1. 判断订单中是否有多个用户,有则禁止下单
	2. 同样存在线程安全问题
	3. 因此需要上锁
	4. 在生成订单方法中存在事务失效问题,因为事务底层是spring通过aop生成代理对象执行方法,而在调用方法处只是简单地this.invokeMethod,this不是代理对象:最终通过AopContext得到代理对象,执行该方法.
	5. 锁的粒度问题:由于不允许同个用户下多单,其他用户仍然可以下单.因此锁的是userId.toString(),但是由于toString底层通过new String生成不同的对象,因此即使是同个userId锁的也不是一个对象:解决办法,使用userId.toString().intern().只要常量池有userId,则返回其引用,确保一个id一个对象.
```
## 分布式锁
```
	因为在集群模式下,每个集群都有自己内部独立的jvm,因此存在多个锁监视器,也就是说,每个集群内都能有一个userId获取到各自集群内的锁.synchronized在集群模式下失效
	# 自定义分布式锁:
		1. 通过redis中setnx命令定义互斥锁(多个jvm可见,实现分布式锁):
			1. 遇到过误删的问题:在unlock时直接删除key,如果业务超时,锁过期后,第一个线程直接删除锁,会把第二个线程的锁释放.解决办法:存入锁时记录uuid+线程id作为标识.
如果是自己的锁,则释放.
			2. 由于判断是否为自己的锁及删除锁的代码不是原子的,如果某个线程在进入if条件内被阻塞,锁超时释放,仍然会删除其他线程的锁(已经进入条件内了).解决:将判断条件以及释放锁代码写入lua脚本,最终通过redis自身执行脚本确保原子性.
		2. 不够完美的地方:不可重入锁,超时释放,失败不可重试,主从一致性问题.
```
### Redisson框架
```
	可重入锁:同一个线程多次获取同一把锁.
	redisson中RLock可重入锁的原理:在某个线程尝试获取锁的时候,判断是否为同一个线程,并且通过cnt计数器计数重入的次数,每次释放锁,先cnt--
```

